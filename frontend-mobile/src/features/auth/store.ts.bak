import '@/polyfills/web';
import { create } from 'zustand';
import { deleteItem, getItem, saveItem } from "@/utils/secureStore";
import { User, hasCapability } from "./types";

// Ensure process.env for SSR/web
if (typeof globalThis.process === 'undefined') {
  (globalThis as any).process = { env: {} };
} else if (typeof (globalThis as any).process.env === 'undefined') {
  (globalThis as any).process.env = {};
}

interface AuthState {
  user: User | null;
  token: string | null;
  refreshToken: string | null;
  approved: boolean;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  login: (user: User, token: string, refreshToken?: string) => Promise<void>;
  logout: () => Promise<void>;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
  initializeAuth: () => Promise<void>;
  hasCapability: (capability: string) => boolean;
  updateUserCapabilities: (capabilities: string[]) => void;
}

const initialState = {
  user: null,
  token: null,
  refreshToken: null,
  approved: false,
  isAuthenticated: false,
  isLoading: true,
  error: null,
} as const;

// Helper for handling timeouts
const withTimeout = <T>(promise: Promise<T>, timeoutMs: number, timeoutMessage: string): Promise<T> => {
  let timeoutHandle: ReturnType<typeof setTimeout>;
  const timeoutPromise = new Promise<T>((_, reject) => {
    timeoutHandle = setTimeout(() => {
      console.log(`ðŸ”§ Timeout reached: ${timeoutMessage}`);
      reject(new Error(timeoutMessage));
    }, timeoutMs);
  });

  return Promise.race([
    promise,
    timeoutPromise
  ]).finally(() => clearTimeout(timeoutHandle));
};

export const useAuthStore = create<AuthState>((set, get) => ({
  ...initialState,

  login: async (user: User, token: string, refreshToken?: string) => {
    try {
      await saveItem("auth_token", token);
      if (refreshToken) {
        await saveItem("refresh_token", refreshToken);
      }
      await saveItem("login_approved", "true");
      set({
        user,
        token,
        refreshToken,
        approved: true,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
    } catch (e) {
      console.error("Login failed:", e);
      set({ error: "Failed to save session", isLoading: false });
    }
  },

  logout: async () => {
    try {
      await deleteItem("auth_token");
      await deleteItem("refresh_token");
      await deleteItem("login_approved");
    } catch (e) {
      console.error("Logout cleanup failed:", e);
    } finally {
      set({
        ...initialState,
        isLoading: false,
      });
    }
  },

  setLoading: (loading: boolean) => set({ isLoading: loading }),
  setError: (error: string | null) => set({ error }),
  clearError: () => set({ error: null }),

  hasCapability: (capability: string): boolean => {
    const state = get();
    return hasCapability(state.user, capability);
  },

  updateUserCapabilities: (capabilities: string[]) => {
    set((state) => ({
      user: state.user ? { ...state.user, capabilities } : null,
    }));
  },

  initializeAuth: async () => {
    console.log('ðŸ”§ initializeAuth: Starting...');
    set({ isLoading: true });

    try {
      // Check for force reset first
      console.log('ðŸ”§ initializeAuth: Checking forceReset...');
      const forceReset = process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === 'true' || 
                        process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === '1';
      
      if (forceReset) {
        console.log('ðŸ”§ initializeAuth: Force resetting auth state...');
        try {
          await deleteItem('auth_token');
          await deleteItem('refresh_token');
          await deleteItem('login_approved');
        } catch (e) {
          console.error('ðŸ”§ initializeAuth: Error during force reset:', e);
        }
        set({ ...initialState, isLoading: false });
        return;
      }

      // Get stored tokens with timeout
      console.log('ðŸ”§ initializeAuth: Getting stored tokens...');
      const [token, refreshToken, approved] = await Promise.all([
        getItem('auth_token'),
        getItem('refresh_token'),
        getItem('login_approved')
      ]);

      console.log('ðŸ”§ initializeAuth: Got tokens:', {
        hasToken: !!token,
        hasRefreshToken: !!refreshToken,
        approved
      });

      // Check environment flags
      const requireOtpOnStart = process.env.EXPO_PUBLIC_REQUIRE_OTP_ON_START === 'true' || 
                               process.env.EXPO_PUBLIC_REQUIRE_OTP_ON_START === '1';
      const bypassOtp = process.env.EXPO_PUBLIC_BYPASS_OTP === 'true' || 
                       process.env.EXPO_PUBLIC_BYPASS_OTP === '1';

      console.log('ðŸ”§ initializeAuth: Environment variables:', {
        requireOtpOnStart,
        bypassOtp,
        EXPO_PUBLIC_WEB_RESET_ON_LOAD: process.env.EXPO_PUBLIC_WEB_RESET_ON_LOAD,
        hasApiKey: !!process.env.EXPO_PUBLIC_BUILDER_API_KEY
      });

      // Only restore session if user had explicitly approved login previously
      if (token && approved === 'true' && !requireOtpOnStart) {
        console.log('ðŸ”§ initializeAuth: Session appears valid, fetching profile...');
        try {
          const { authService } = await import('../../services/auth');
          const profileResp = await withTimeout(
            authService.getProfile(),
            8000,
            'Profile fetch timeout'
          );

          console.log('ðŸ”§ initializeAuth: Profile fetch complete:', 
            profileResp.success ? 'SUCCESS' : 'FAILED');

          if (profileResp.success && profileResp.data) {
            console.log('ðŸ”§ initializeAuth: Setting authenticated state with profile');
            // Map API response to our User type
            const user: User = {
              id: profileResp.data.id,
              unique_id: profileResp.data.id, // Use same ID for backward compatibility
              email: profileResp.data.email,
              name: profileResp.data.name,
              phone: profileResp.data.phone,
              is_active: profileResp.data.isVerified ?? true,
              capabilities: [], // Initialize empty, will be fetched separately
              created_at: profileResp.data.createdAt,
              updated_at: profileResp.data.updatedAt,
              // Legacy fields
              isVerified: profileResp.data.isVerified,
              createdAt: profileResp.data.createdAt,
              updatedAt: profileResp.data.updatedAt
            };
            set({
              user,
              token,
              refreshToken,
              approved: true,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });
            
            // Fetch capabilities separately
            authService.getCapabilities()
              .then(capsResp => {
                if (capsResp.success && Array.isArray(capsResp.data)) {
                  set(state => ({
                    user: state.user ? { ...state.user, capabilities: capsResp.data } : state.user
                  }));
                }
              })
              .catch(e => console.error('Failed to fetch capabilities:', e));

          } else {
            const unauthorized = (profileResp.error || '').toLowerCase().includes('unauthorized') || 
                               (profileResp as any).status === 401;
            console.log('ðŸ”§ initializeAuth: Profile fetch failed:', 
              unauthorized ? 'UNAUTHORIZED' : 'OTHER_ERROR');

            if (unauthorized) {
              console.log('ðŸ”§ initializeAuth: Clearing invalid session');
              await deleteItem('auth_token');
              await deleteItem('refresh_token');
              set({ ...initialState, isLoading: false });
            } else {
              console.log('ðŸ”§ initializeAuth: Keeping session for retry');
              set({
                user: null,
                token,
                refreshToken,
                approved: true,
                isAuthenticated: true,
                isLoading: false,
                error: null,
              });
            }
          }
        } catch (err) {
          console.log('ðŸ”§ initializeAuth: Error during profile fetch:', err);
          set({
            user: null,
            token,
            refreshToken,
            approved: true,
            isAuthenticated: true,
            isLoading: false,
            error: 'Failed to fetch user profile'
          });
        }
      } else {
        console.log('ðŸ”§ initializeAuth: No valid session found');
        try { await deleteItem('login_approved'); } catch {}
        set({ ...initialState, isLoading: false });
      }
    } catch (e) {
      console.error('ðŸ”§ initializeAuth: Failed:', e);
      set({ ...initialState, isLoading: false, error: 'Failed to initialize auth' });
    }
  }
}));

  ...initialState,
  user: null,
  token: null,
  refreshToken: null,
  approved: false,
  isAuthenticated: false,
  isLoading: true,
  error: null,

  login: async (user: User, token: string, refreshToken?: string) => {
    try {
      await saveItem("auth_token", token);
      if (refreshToken) {
        await saveItem("refresh_token", refreshToken);
      }
      // Mark that user explicitly approved login (e.g., after OTP)
      await saveItem("login_approved", "true");
      set({
        user,
        token,
        refreshToken,
        approved: true,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
    } catch (e) {
      console.error("Login failed:", e);
      set({ error: "Failed to save session", isLoading: false });
    }
  },

  logout: async () => {
    try {
      await deleteItem("auth_token");
      await deleteItem("refresh_token");
      await deleteItem("login_approved");
    } catch (e) {
      console.error("Logout cleanup failed:", e);
    } finally {
      set({
        user: null,
        token: null,
        refreshToken: null,
        approved: false,
        isAuthenticated: false,
        isLoading: false,
        error: null,
      });
    }
  },

  setLoading: (loading: boolean) => set({ isLoading: loading }),
  setError: (error: string | null) => set({ error }),
  clearError: () => set({ error: null }),

  hasCapability: (capability: string): boolean => {
    const state = get();
    return hasCapability(state.user, capability);
  },

  updateUserCapabilities: (capabilities: string[]) => {
    set((state) => ({
      user: state.user ? { ...state.user, capabilities } : null,
    }));
  },

  initializeAuth: async () => {
    console.log('ðŸ”§ initializeAuth: Starting...');
    set({ isLoading: true });
    
    try {
      // Check for force reset first
      console.log('ðŸ”§ initializeAuth: Checking forceReset...');
      const forceReset = process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === 'true' || 
                        process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === '1';
      
      if (forceReset) {
        console.log('ðŸ”§ initializeAuth: Force resetting auth state...');
        try {
          await deleteItem('auth_token');
          await deleteItem('refresh_token');
          await deleteItem('login_approved');
        } catch (e) {
          console.error('ðŸ”§ initializeAuth: Error during force reset:', e);
        }
        set({ ...initialState, isLoading: false });
        return;
      }
    set({ isLoading: true });

    try {
      // Check for force reset first
      console.log('ðŸ”§ initializeAuth: Checking forceReset...');
      const forceReset = process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === 'true' || 
                        process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === '1';
      
      if (forceReset) {
        console.log('ðŸ”§ initializeAuth: Force resetting auth state...');
        try {
          await deleteItem('auth_token');
          await deleteItem('refresh_token');
          await deleteItem('login_approved');
        } catch (e) {
          console.error('ðŸ”§ initializeAuth: Error during force reset:', e);
        }
        set({ ...initialState, isLoading: false });
        return;
      }
      try {
      console.log('ðŸ”§ initializeAuth: Checking forceReset...');
      const forceReset = (process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === 'true' || process.env.EXPO_PUBLIC_RESET_LOGIN_ON_START === '1');
      console.log('ðŸ”§ initializeAuth: forceReset =', forceReset);
      if (forceReset) {
        console.log('ðŸ”§ initializeAuth: Resetting login state...');
        try {
          await deleteItem('auth_token');
          await deleteItem('refresh_token');
          await deleteItem('login_approved');
        } catch (e) {
          console.error('ðŸ”§ initializeAuth: Error during reset:', e);
        }
        set({ user: null, token: null, refreshToken: null, approved: false, isAuthenticated: false, isLoading: false, error: null });
        console.log('ðŸ”§ initializeAuth: Reset complete');
        return;
      }

      console.log('ðŸ”§ initializeAuth: Getting stored tokens...');
      const token = await getItem("auth_token");
      console.log('ðŸ”§ initializeAuth: Got auth_token:', token ? 'EXISTS' : 'NULL');
      const refreshToken = await getItem("refresh_token");
      console.log('ðŸ”§ initializeAuth: Got refresh_token:', refreshToken ? 'EXISTS' : 'NULL');
      const approved = await getItem("login_approved");
      console.log('ðŸ”§ initializeAuth: Got login_approved:', approved);
      const requireOtpOnStart = (process.env.EXPO_PUBLIC_REQUIRE_OTP_ON_START === 'true' || process.env.EXPO_PUBLIC_REQUIRE_OTP_ON_START === '1');
      const bypassOtp = (process.env.EXPO_PUBLIC_BYPASS_OTP === 'true' || process.env.EXPO_PUBLIC_BYPASS_OTP === '1');
      
      // Debug logging for environment variables
      console.log('ðŸ”§ initializeAuth: Environment variables:', {
        requireOtpOnStart,
        bypassOtp,
        EXPO_PUBLIC_WEB_RESET_ON_LOAD: process.env.EXPO_PUBLIC_WEB_RESET_ON_LOAD,
        hasApiKey: !!process.env.EXPO_PUBLIC_BUILDER_API_KEY
      });

      // Only restore session if user had explicitly approved login previously
      if (token && approved === 'true' && !requireOtpOnStart) {
        console.log('ðŸ”§ initializeAuth: Session appears valid, fetching profile...');
        // Proactively fetch user profile using shared API service
        // Dynamic import to avoid circular deps at module load
        try {
          const { authService } = await import('../../services/auth');
          
          console.log('ðŸ”§ initializeAuth: Starting profile fetch...');
          // Add timeout to prevent hanging on profile fetch
          console.log('ðŸ”§ initializeAuth: Setting up profile fetch timeout...');
          const profilePromise = authService.getProfile();
          const profileTimeoutPromise = new Promise((_, reject) => 
            setTimeout(() => {
              console.log('ðŸ”§ initializeAuth: Profile fetch timeout reached');
              reject(new Error('Profile fetch timeout'));
            }, 8000)
          );
          
          const profileResp = await Promise.race([profilePromise, profileTimeoutPromise]) as any;
          console.log('ðŸ”§ initializeAuth: Profile fetch complete:', profileResp?.success ? 'SUCCESS' : 'FAILED');
          
          if (profileResp.success && profileResp.data) {
            console.log('ðŸ”§ initializeAuth: Setting authenticated state with profile');
            const user: User = {
              id: profileResp.data.id,
              unique_id: profileResp.data.id,
              email: profileResp.data.email,
              name: profileResp.data.name,
              phone: profileResp.data.phone,
              is_active: true,
              capabilities: profileResp.data.capabilities || [],
              created_at: profileResp.data.createdAt,
              updated_at: profileResp.data.updatedAt,
              // Legacy fields
              isVerified: profileResp.data.isVerified,
              createdAt: profileResp.data.createdAt,
              updatedAt: profileResp.data.updatedAt
            };
            set({
              user,
              token,
              refreshToken,
              approved: true,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });
          } else {
            // If unauthorized, clear session; otherwise keep session and allow lazy fetch later
            const unauthorized = (profileResp.error || '').toLowerCase().includes('unauthorized') || (profileResp as any).status === 401;
            console.log('ðŸ”§ initializeAuth: Profile fetch failed:', unauthorized ? 'UNAUTHORIZED' : 'OTHER_ERROR');
            if (unauthorized) {
              console.log('ðŸ”§ initializeAuth: Clearing invalid session');
              await deleteItem('auth_token');
              await deleteItem('refresh_token');
              set({ user: null, token: null, refreshToken: null, approved: false, isAuthenticated: false, isLoading: false, error: null });
            } else {
              console.log('ðŸ”§ initializeAuth: Keeping session for retry');
              set({ user: null, token, refreshToken, approved: true, isAuthenticated: true, isLoading: false, error: null });
            }
          }
        } catch (err) {
          console.log("ðŸ”§ initializeAuth: Error during profile fetch:", err);
          // Network or other error: keep auth state, user will be fetched later
          set({ user: null, token, refreshToken, approved: true, isAuthenticated: true, isLoading: false, error: null });
        }
      } else {
        console.log('ðŸ”§ initializeAuth: No valid session found');
        try { await deleteItem('login_approved'); } catch {}
        set({
          user: null,
          token: null,
          refreshToken: null,
          approved: false,
          isAuthenticated: false,
          isLoading: false,
          error: null,
        });
      }
      } catch (e) {
        console.error("ðŸ”§ initializeAuth: Failed to initialize auth:", e);
        set({
          user: null,
          token: null,
          refreshToken: null,
          isAuthenticated: false,
          isLoading: false,
          error: "Failed to load session",
        });
      }
    })();
    
    try {
      await Promise.race([initPromise, timeoutPromise]);
    } catch (error) {
      console.error("Auth initialization failed or timed out:", error);
      set({
        user: null,
        token: null,
        refreshToken: null,
        isAuthenticated: false,
        isLoading: false,
        error: error instanceof Error ? error.message : "Auth initialization failed",
      });
    }
    // Final state dump for debugging
    const final = useAuthStore.getState();
    console.log('ðŸ”§ initializeAuth: finished. final state:', {
      approved: final.approved,
      isLoading: final.isLoading,
      isAuthenticated: final.isAuthenticated,
      token: final.token ? 'SET' : 'NULL',
    });
  },
}));

// You can now call initializeAuth in your App entry file instead of here
